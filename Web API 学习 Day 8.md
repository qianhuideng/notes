# Web API 学习 Day 8

上周完成了获取密钥接口的Controller层和Service层的大部分代码，但遗留了用户ID传参的问题，今天采取了直接传参的形式，成功的解决了问题，请教段工和黄工后，在业务逻辑和代码简洁度上对原有代码做了完善和优化。同时开始了第二个接口（检查脚本），下面就今天的工作内容做了梳理。



## 解决UserId传参：

![image-20210809210237122](C:\Users\jsz4580.SZEVOC\AppData\Roaming\Typora\typora-user-images\image-20210809210237122.png)

![image-20210809210257447](C:\Users\jsz4580.SZEVOC\AppData\Roaming\Typora\typora-user-images\image-20210809210257447.png)

![image-20210809210327519](C:\Users\jsz4580.SZEVOC\AppData\Roaming\Typora\typora-user-images\image-20210809210327519.png)

上周的想法是单独设置一个传递参数的函数，返回string类型，但用到最后发现调用时还要传参，可那个参数不就是我想要的吗，何必多次一举，还查询了构造器、属性等等，后来发现直接传参进总的方法不就好了么，不管参数是什么，都可以直接调用，本来这个参数也是前端传过来的，我们接收就好。只有在某个参数类型要在多个场景用到、需要反复赋值时，我们才会单独设置一个字段属性来调用。



## 原有代码改进：

上周五晚上请教导师时提到了把数据缓存进Redis里前，要先检查一下Redis里有没有这个值，考虑有怎么办、没有怎么办，这是我之前忽略的点，直接进行了缓存，如果没有key就直接缓存进去，如果有就删除后再缓存，因为如果不删key和密钥的生命周期就会不同，所以要及时删除。

把key不存在的情况写在前面就要进行两次重复的存储，代码有些冗余，所以把key存在写在前面，不管在不在都要重新执行一次缓存，代码变得简洁。

对比黄工的代码后，发现他在存储用户ID时加上了前缀，这就有效的避免了代码混乱、命名冲突的情况，因为我们现在是微服务开发，同样的Redis不同的业务在使用，同时存UserId，很容易发生冲突，巧用前缀就解决了这个问题。同时在返回的时候黄工同时的返回了生命时长，因为后续可能会有变动，通过返回值得方法及时和前端沟通。这两点在之后的接口编写中我都会注意。

![image-20210809212554185](C:\Users\jsz4580.SZEVOC\AppData\Roaming\Typora\typora-user-images\image-20210809212554185.png)

最后的接口调用结果，成功的返回了生成的密钥：

![image-20210809212747519](C:\Users\jsz4580.SZEVOC\AppData\Roaming\Typora\typora-user-images\image-20210809212747519.png)



## 工作心得：

  - 在编写第二个接口（检查脚本）的时候对于如何调用另一个Api有很多的疑问，比如调用方式和前端调用我们一样吗、应该怎样获取要调用Api接口的地址呢、传入的参数是什么等等，晚上和黄工沟通后才解开这些疑问。两个接口之间会互通Url地址，直接在方法中调用即可，参数的传入参考swagger暴露出来的即可，这点和前端相同，我们要想办法从前端获取，设备服务层不用了解这些参数的具体含义，我们只是起到一个转交和重新组装的作用，调用的接口要什么参数我们就给他们，直接调用封装好的方法HttpPostClient，后续操作如序列化、反序列化、封装方法等我们不需要管，只需向前端返回结果即可。


